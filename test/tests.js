const ava = require('ava')
const {readFileSync} = require('fs')
const {join} = require('path')
const {fakeIpc} = require('./util/util.js')
const {pack, unpack} = require('msgpackr')
const JsIsolateConfineRuntime = require('../index.js')

const get = path => readFileSync(path)

ava('Basic', async t => {
  const ipc = fakeIpc()
  const path = join(__dirname, 'programs', 'basic.js')
  const runtime = new JsIsolateConfineRuntime({source: get(path), path, ipc})
  await runtime.init()
  await runtime.run()
  await runtime.close()
  t.is(ipc.messages.length, 2)
  t.is(ipc.messages[0].type, 'notify')
  t.deepEqual(ipc.messages[0].body.params, {stderr: false, data: 'hello, world'})
  t.is(ipc.messages[1].type, 'notify')
  t.deepEqual(ipc.messages[1].body.params, {stderr: true, data: 'hello, error'})
})

ava('No FS access', async t => {
  const ipc = fakeIpc()
  const path = join(__dirname, 'programs', 'no-fs.js')
  const runtime = new JsIsolateConfineRuntime({source: get(path), path, ipc})
  await runtime.init()
  await t.throwsAsync(() => runtime.run())
  t.is(ipc.messages.length, 0)
})

ava('Requests', async t => {
  const ipc = fakeIpc()
  const path = join(__dirname, 'programs', 'messaging.js')
  const runtime = new JsIsolateConfineRuntime({source: get(path), path, ipc})
  await runtime.init()
  await runtime.run()
  const res = await runtime.handleRequest(pack({hello: 'request'})).then(res => unpack(res), err => {throw new Error(unpack(err).message)})
  await runtime.close()
  t.is(ipc.messages.length, 2)
  t.is(ipc.messages[0].type, 'request')
  t.deepEqual(ipc.messages[0].body, {isRequest: true})
  t.is(ipc.messages[1].type, 'notify')
  t.deepEqual(ipc.messages[1].body, {isNotify: true})
  t.deepEqual(res, {hello: 'request'})
})

ava('Exit code', async t => {
  const ipc = fakeIpc()
  const path = join(__dirname, 'programs', 'exitcode.js')
  const runtime = new JsIsolateConfineRuntime({source: get(path), path, ipc})
  let exitCode = undefined
  runtime.on('closed', _exitCode => { exitCode = _exitCode })
  await runtime.init()
  await runtime.run()
  t.is(exitCode, 1)
})
